Package wig;

Helpers
    any = [0x0 .. 0xfffff];
    

    tab     = 9; 
    cr      = 13; 
    lf      = 10;
    digit   = ['0'..'9'];
    lowercase = ['a'..'z'];
    uppercase = ['A'..'Z']; 
    letter  = lowercase | uppercase;
    idletter = letter | '_';
    idchar  = letter | '_' | digit;    
    double_quote = '"';

    any_str = [any - [cr + lf]];


States
	wig_scope, html_scope, wig_comment_scope, html_comment_scope, holes_scope, html_tags_scope;

Tokens
    eol = cr | lf | cr lf;

    blank = ' ' | tab;

    {wig_scope} service = 'service';
    {wig_scope} const = 'const';
    {wig_scope} html = 'html';

    {html_tags_scope} input = 'input';
    {html_tags_scope} select = 'select';
    {html_tags_scope} type = 'type';
    {html_tags_scope} name = 'name';
    {html_tags_scope} text = 'text';
    {html_tags_scope} radio = 'radio';

    {wig_scope} schema = 'schema';
    {wig_scope} session = 'session';
    {wig_scope} show = 'show';
    {wig_scope} exit = 'exit';
    {wig_scope} return = 'return';
    {wig_scope} if = 'if';
    {wig_scope} else = 'else';
    {wig_scope} while = 'while';
    {wig_scope} plug = 'plug';
    {wig_scope} receive = 'receive';
    {wig_scope} int = 'int';
    {wig_scope} bool = 'bool';
    {wig_scope} string = 'string';
    {wig_scope} void = 'void';
    {wig_scope} tuple = 'tuple';
    {wig_scope} true = 'true';
    {wig_scope} false = 'false';
    {wig_scope} l_brace = '{';
    {wig_scope} r_brace = '}';

    {wig_scope} assign = '=';

    {wig_scope} semicolon = ';';
    {wig_scope} lt = '<';
    {wig_scope} gt = '>';

    {html_scope} lt_slash = '</';

    {wig_scope} l_par = '(';
    {wig_scope} r_par = ')';
    {wig_scope} l_bracket = '[';
    {wig_scope} r_bracket = ']';
    {wig_scope} comma = ',';
    {wig_scope} keep = '\+';
    {wig_scope} remove = '\-';
    {wig_scope} join = '<<';
    {wig_scope} eq = '==';
    {wig_scope} neq = '!=';
    {wig_scope} lteq = '<=';
    {wig_scope} gteq = '>=';
    {wig_scope} not = '!';
    {wig_scope} minus = '-';
    {wig_scope} plus = '+';
    {wig_scope} mult = '*';
    {wig_scope} div = '/';
    {wig_scope} mod = '%';
    {wig_scope} and = '&&';
    {wig_scope} or = '||';
    {wig_scope} dot = '.';

    {wig_scope, holes_scope} identifier = idletter idchar*;

    {wig_scope} intconst = '0'| [digit-'0'] digit*;

    {wig_scope} stringconst = double_quote any_str* double_quote;

    {html_scope->html_comment_scope} html_comment_start = '<!--';
    {html_comment_scope->html_scope} html_comment_end = '-->';

    {html_scope->html_tags_scope} html_tags_start = '<';
    {html_tags_scope->html_scope} html_tags_end = '>';
 
    {html_scope->holes_scope} lt_bracket = '<[';
    {holes_scope->html_scope} gt_bracket = ']>';

    {wig_scope->html_scope} html_tag_start = '<html>';
    {html_scope->wig_scope} html_tag_end = '</html>';


    {html_comment_scope} meta = '<!--' any* '-->';
	
    {wig_scope->wig_comment_scope} wig_comment_start = '/*';
    {wig_comment_scope->wig_scope} wig_comment_end = '*/';



    {html_scope} whatever = [any - ['>' + '<']]*;

IgnoredTokens
    blank, eol;

Productions
    service =
        T.service l_brace [p_html]:P.html+ [schemas]:P.schema* [vars]:variable* [funcs]:function* [sessions]:P.session+ r_brace
        {-> New service([p_html], [schemas], [vars], [funcs], [sessions])};

    html = 
        const T.html identifier assign html_tag_start [html_bodies]:htmlbody* html_tag_end semicolon
        {-> New html(identifier, [html_bodies])};

    htmlbody =
        {tag_start} lt identifier attribute* gt
        {-> New htmlbody.tag_start(identifier, [attribute])} |
        {tag_end}   lt_slash identifier gt
        {-> New htmlbody.tag_end(identifier)} |
        {hole} lt_bracket identifier gt_bracket
        {-> New htmlbody.hole(identifier)} |
        {whatever}  whatever 
        {-> New htmlbody.whatever(whatever)}|
        {meta} meta 
        {-> New htmlbody.meta(meta)}|
        {input} lt T.input inputattr+ gt
        {-> New htmlbody.input([inputattr])} |
        {select} lt [select_tag]:select inputattr+ [first_gt]:gt htmlbody* lt_slash select [second_gt]:gt
        {-> New htmlbody.select(select_tag, [inputattr], [htmlbody], select)};

    inputattr =
        {name} name assign attr 
        {-> New inputattr.name(attr)} |
        {type} T.type assign inputtype 
        {-> New inputattr.type(inputtype)} |
        {attribute} attribute
        {-> New inputattr.attribute(attribute)};

    inputtype =
        {text}  text 
        {-> New inputtype.text(text)}|
        {radio} radio
        {-> New inputtype.radio(radio)};

    attribute =
        {attr}  attr 
        {-> New attribute.attr(attr)}| 
        {assign} [left_attr]:attr assign [right_attr]:attr
        {-> New attribute.assign(left_attr, right_attr)};

    attr = 
        {id}  identifier 
        {-> New attr.id(identifier)}| 
        {str} stringconst
        {-> New attr.str(stringconst)};

    schema =
        T.schema identifier l_brace field* r_brace
        {-> New schema(identifier, [field])};

    field =
        simpletype identifier semicolon
        {-> New field(simpletype.type, identifier)};

    variable =
        [ptype]:P.type identifier_list semicolon
        {-> New variable(ptype.type,[identifier_list.identifier])};

    identifier_list {-> identifier*} =
        identifier identifier_list_tail*
        {-> [identifier, identifier_list_tail.identifier]};  

    identifier_list_tail{-> identifier} = 
        comma identifier
        {-> identifier};

    simpletype {-> P.type} =
        {int}    int
        {-> New type.int(int)} | 
        {bool}   bool 
        {-> New type.bool(bool)}|
        {string} string 
        {-> New type.string(string)}|
        {void}   void
        {-> New type.void(void)};

    type {-> P.type} =
        {simple} simpletype 
        {-> simpletype.type} |
        {tuple}  tuple identifier
        {-> New type.tuple(identifier)};


    arguments{-> argument*} =
        argument arguments_tail*
        {-> [argument.argument, arguments_tail.argument]};

    arguments_tail {-> argument} = 
        comma argument
        {-> argument.argument};

    argument{-> argument} =
        P.type identifier
        {-> New argument(P.type.type, identifier)};

    session =
        T.session identifier l_par r_par compoundstm
        {-> New session(identifier, compoundstm.stm)};

    stm{-> stm} =
        {no}     semicolon 
        {-> New stm.no()} |
        {declaration} variable
        {-> New stm.declaration(variable)}|            
        {show}   show document P.receive? semicolon 
        {-> New stm.show(document, receive.exp)} |
        {exit}   exit document semicolon 
        {-> New stm.exit(document)} |
        {return} return semicolon 
        {-> New stm.return()} |
        {retexp} return exp semicolon 
        {-> New stm.retexp(exp)} |
        {if}     if l_par exp r_par stm 
        {-> New stm.if(exp, stm)} |
        {ifelse} if l_par exp r_par [then_stm]:stm_no_short_if else [else_stm]:stm 
        {-> New stm.ifelse(exp, then_stm.stm, else_stm.stm)} |
        {while}  while l_par exp r_par stm 
        {-> New stm.while(exp, stm)} |
        {comp}   compoundstm 
        {-> compoundstm.stm } |                
        {exp}    exp semicolon
        {-> New stm.exp(exp) };

    stm_no_short_if{-> stm} =
        {no}     semicolon 
        {-> New stm.no()} |
        {declaration} variable
        {-> New stm.declaration(variable)}|               
        {show}   show document P.receive? semicolon 
        {-> New stm.show(document, receive.exp)} |
        {exit}   exit document semicolon 
        {-> New stm.exit(document)} |
        {return} return semicolon 
        {-> New stm.return()} |
        {retexp} return exp semicolon 
        {-> New stm.retexp(exp)} |
        {ifelse} if l_par exp r_par [then_stm]:stm_no_short_if else [else_stm]:stm_no_short_if 
        {-> New stm.ifelse(exp, then_stm.stm, else_stm.stm)} |
        {while}  while l_par exp r_par stm 
        {-> New stm.while(exp, stm)} |
        {comp}   compoundstm 
        {-> compoundstm.stm } |                
        {exp}    exp semicolon
        {-> New stm.exp(exp) };

    document{-> document} =
        {id}   identifier 
        {-> New document.id(identifier)} |
        {plug} T.plug identifier l_bracket plugs r_bracket
        {-> New document.plug(identifier, [plugs.plug])};

    receive{-> exp} =
       T.receive l_bracket inputs r_bracket
       {-> New exp.receive([inputs.exp])};

    compoundstm{-> stm} =
        l_brace [var_list]:variable* [stm_list]:stm* r_brace
        {->New stm.comp([var_list], [stm_list])};

    block_item_list {-> stm*} = 
        block_item+
        {-> [block_item.stm]};

    block_item {->stm} = 
        {decl} variable 
        {-> New stm.declaration(variable)} |
        {stm} stm
        {-> stm};  
    
    function =
        P.type identifier l_par arguments? r_par compoundstm
        {-> New function.simple(P.type.type, identifier, [arguments.argument], compoundstm.stm)};

    plugs{-> P.plug*} =
        P.plug plugs_tail*
        {-> [P.plug, plugs_tail.plug]};
    
    plugs_tail{-> P.plug} = 
        P.plug
        {-> P.plug}; 
    
    plug {-> P.plug} =
        identifier assign exp
        {-> New plug(identifier, exp)};

    inputs{-> exp*} =
        P.input input_tail*
        {-> [input.exp, input_tail.exp]};
    
    input_tail{-> exp} = 
        P.input
        {-> input.exp};

    input{-> exp} =
        lvalue assign identifier
        {-> New exp.input(lvalue, identifier)};

    exp{-> exp} =
        {assign}  lvalue assign or_exp 
        {-> New exp.assign(lvalue, or_exp.exp)} |
        {default} or_exp
        {-> or_exp.exp};

    or_exp{-> exp}=
        {or} [left]:or_exp or [right]:and_exp 
        {-> New exp.or(left.exp, right.exp)}|
        {default} and_exp
        {-> and_exp.exp};

    and_exp{-> exp} =
        {and} [left]:and_exp and [right]:cmp_exp
        {-> New exp.and(left.exp, right.exp)} |
        {default} cmp_exp
        {-> cmp_exp.exp};

    cmp_exp{-> exp} =
        {eq} [left]:add_exp eq [right]:add_exp 
        {-> New exp.eq(left.exp, right.exp)} |
        {neq} [left]:add_exp neq [right]:add_exp 
        {-> New exp.neq(left.exp, right.exp)} |
        {lt} [left]:add_exp lt [right]:add_exp 
        {-> New exp.lt(left.exp, right.exp)} |
        {gt} [left]:add_exp gt [right]:add_exp 
        {-> New exp.gt(left.exp, right.exp)} |
        {lteq} [left]:add_exp lteq [right]:add_exp 
        {-> New exp.lteq(left.exp, right.exp)} |
        {gteq} [left]:add_exp gteq [right]:add_exp 
        {-> New exp.gteq(left.exp, right.exp)} |
        {default} add_exp
        {-> add_exp.exp};

    add_exp{-> exp} =
        {plus} [left]:add_exp plus [right]:mult_exp 
        {-> New exp.plus(left.exp, right.exp)} |
        {minus} [left]:add_exp minus [right]:mult_exp 
        {-> New exp.minus(left.exp, right.exp)} |
        {default} mult_exp
        {-> mult_exp.exp};

    mult_exp{-> exp} =
        {mult} [left]:mult_exp mult [right]:join_exp 
        {-> New exp.mult(left.exp, right.exp)}|
        {div} [left]:mult_exp div [right]:join_exp 
        {-> New exp.div(left.exp, right.exp)}|
        {mod} [left]:mult_exp mod [right]:join_exp 
        {-> New exp.mod(left.exp, right.exp)} |
        {default} join_exp
        {-> join_exp.exp};

    join_exp{-> exp} = 
        {join} [left]:tuple_exp join [right]:join_exp 
        {-> New exp.join(left.exp, right.exp)}|
        {default} tuple_exp
        {-> tuple_exp.exp};
        
    tuple_exp{-> exp} =
        {keep} tuple_exp keep identifier 
        {-> New exp.keep(tuple_exp.exp, identifier)}|
        {remove} tuple_exp remove identifier 
        {-> New exp.remove(tuple_exp.exp, identifier)}|
        {keep_many} tuple_exp keep l_par identifier_list r_par 
        {-> New exp.keep_many(tuple_exp.exp, [identifier_list.identifier])}|
        {remove_many} tuple_exp remove l_par identifier_list r_par 
        {-> New exp.remove_many(tuple_exp.exp, [identifier_list.identifier])}|
        {default} unary_exp
        {-> unary_exp.exp};

    unary_exp{-> exp} =
        {not} not base_exp 
        {-> New exp.not(base_exp.exp)}|
        {neg} minus base_exp 
        {-> New exp.neg(base_exp.exp)}|
        {default} base_exp
        {-> base_exp.exp};

    base_exp{-> exp} =
        {lvalue} lvalue 
        {-> New exp.lvalue(lvalue)}|
        {call}   identifier l_par [expressions]:exps? r_par 
        {-> New exp.call(identifier, [expressions.exp]) }|
        {int}    intconst 
        {-> New exp.int(intconst)}|
        {true}   true 
        {-> New exp.true(true)}|
        {false}  false 
        {-> New exp.false(false)}|
        {string} stringconst 
        {-> New exp.string(stringconst)}|
        {tuple}  tuple l_brace [fieldvaluelist]:fieldvalues? r_brace 
        {-> New exp.tuple([fieldvaluelist.exp])}|
        {paren}  l_par exp r_par
        {-> New exp.paren(exp)};

    exps {-> exp*} =
       exp exps_tail*
        {-> [exp, exps_tail.exp]};

    exps_tail {-> exp} = 
        comma exp
        {-> exp};

    lvalue {-> lvalue} =
        {simple} identifier 
        {-> New lvalue.simple(identifier)}| 
        {qualified} [left]:identifier dot [right]:identifier
        {-> New lvalue.qualified(left, right)};

    fieldvalues {-> exp*} =
        fieldvalue fieldvalue_tail*
        {-> [fieldvalue.exp, fieldvalue_tail.exp]};

    fieldvalue_tail {-> exp} =
        comma fieldvalue
        {-> fieldvalue.exp};

    fieldvalue {-> exp} =
        identifier assign exp
        {-> New exp.assign(New lvalue.simple(identifier), exp)};

Abstract Syntax Tree

    service = 
        [htmls]:P.html+ [schemas]:P.schema* [variables]:variable* [functions]:P.function* [sessions]:P.session+;
    
    variable = 
        P.type [identifiers]:identifier+;

    html = 
        identifier [htmlbodies]:htmlbody*;

    htmlbody = 
        {tag_start} identifier attribute* |
        {tag_end} identifier |
        {hole} identifier |
        {whatever} whatever |
        {meta} meta | 
        {input} [inputattrs]:inputattr+ |
        {select} [select_tag]:select inputattr+ htmlbody* select;

    inputattr = 
        {name} attr |
        {type} inputtype |
        {attribute} attribute;

    inputtype = 
        {text} text |
        {radio} radio;

    attribute = 
        {attr} attr | 
        {assign} [left]:attr [right]:attr;

    attr = 
        {id} identifier | 
        {str} stringconst;

    session = 
        identifier stm;

    schema = 
        identifier [fields]:field*;

    type =
        {int} int |
        {bool} bool |
        {string} string |
        {void} void|
        {tuple} identifier;

    function = 
        {simple} P.type identifier [arguments]:argument* stm;

    argument =
        P.type identifier;

    stm =
        {no} |
        {declaration} variable |
        {show} document exp? |
        {exit} document |
        {return} |
        {retexp} exp |
        {if} exp stm |
        {ifelse} exp [then_stm]:stm [else_stm]:stm | 
        {while} exp stm |
        {comp} [first]:variable* [second]:stm* | 
        {exp} exp;

    field = 
        P.type identifier;

    document = 
        {id} identifier | 
        {plug} identifier [plugs]:P.plug+;

    plug = 
        identifier exp;

    exp =
        {assign} lvalue exp |
        {or} [left]:exp [right]:exp |
        {and} [left]:exp [right]:exp |
        {eq} [left]:exp [right]:exp |
        {neq} [left]:exp [right]:exp |
        {lt} [left]:exp [right]:exp |
        {gt} [left]:exp [right]:exp |
        {lteq} [left]:exp [right]:exp |
        {gteq} [left]:exp [right]:exp |
        {plus} [left]:exp [right]:exp |
        {minus} [left]:exp [right]:exp |
        {mult} [left]:exp [right]:exp |
        {div} [left]:exp [right]:exp |
        {mod} [left]:exp [right]:exp |
        {join} [left]:exp [right]:exp |
        {keep} exp identifier |
        {remove} exp identifier |
        {keep_many} exp [fields]:identifier+ |
        {remove_many} exp [fields]:identifier+ |
        {not} exp |
        {neg} exp |
        {lvalue} lvalue |
        {call} identifier [args]:exp+ |
        {int} intconst |
        {id} identifier |
        {true} true |
        {false} false |
        {string} stringconst |
        {tuple} [field_decls]:exp* |
        {paren} exp |
        {input} lvalue identifier |
        {receive} [values]:exp+;

    lvalue =
        {simple}    identifier | 
        {qualified} [left]:identifier [right]:identifier;   
