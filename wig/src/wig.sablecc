Package wig;
/*******************************************************************
* Helpers *
*******************************************************************/
Helpers
all = [0..0xffff];
letter = [['a'..'z'] + ['A'..'Z']];
digit = ['0'..'9'];
letter_or_digit = letter | digit;
letter_or_digit_or_us = letter_or_digit | '_';
letter_or_us = letter | '_';
tab = 9;
cr = 13;
lf = 10;
notdash = [all - '-'];
notmeta_stmt = [notdash -'>'];
notquote = [all-'"'];
notstar = [all-'*'];
notstar_backslash = [notstar -'/'];
not_cr_lf = [all - [lf+cr]];
eol = lf|cr|cr lf;
escapequote = '\"';
meta_start = '<!--';
meta_end = '-->';
meta_stmt = meta_start notdash* '-'+ (notmeta_stmt notdash* '-'+)* meta_end;
string_const = '"' (notquote* escapequote* notquote*)* '"';
sl_comment = '//' not_cr_lf* eol;
ml_comment = '/*' notstar* '*'+(notstar_backslash notstar* '*' +)* '/';
comment = sl_comment|ml_comment;
whatever_stmt = [[all-'<']-'>']*; //anything without < and >
/*******************************************************************
* States *
*******************************************************************/
States
wig_block,html_code,whatever_text,form_input;
/*******************************************************************
* Tokens *
*******************************************************************/
Tokens
/*********************
* Keywords *
*********************/
{wig_block} service = 'service';
{wig_block} const = 'const';
{wig_block} html = 'html';
{wig_block->html_code,html_code} html_tag_start = '<html>';
{html_code->wig_block,whatever_text->html_code,wig_block} html_tag_end = '</html>';
{html_code->form_input} input = 'input';
{html_code,form_input,wig_block} posint_const = '0' | [digit-'0'] digit*;
{html_code} negint_const = '-' [digit-'0'] digit*;
{html_code} select = 'select';
{form_input} type = 'type';
{form_input} name = 'name';
{form_input} text = 'text';
{form_input} radio = 'radio';
{wig_block} schema = 'schema';
{wig_block} session = 'session';
{wig_block} show = 'show';
{wig_block} exit = 'exit';
{wig_block} return = 'return';
{wig_block} if = 'if';
{wig_block} else = 'else';
{wig_block} while = 'while';
{wig_block} plug = 'plug';
{wig_block} receive = 'receive';
{wig_block} int = 'int';
{wig_block} bool = 'bool';
{wig_block} string = 'string';
{wig_block} void = 'void';
{wig_block} tuple = 'tuple';
{wig_block} true = 'true';
{wig_block} false = 'false';
/*********************
* Operators *
*********************/
{wig_block} l_brace = '{';
{wig_block} r_brace = '}';
{wig_block,html_code,form_input} assign = '=';
{wig_block, html_code->wig_block} semicolon = ';';
{wig_block,whatever_text->html_code,html_code} lt = '<';
{wig_block,html_code->whatever_text,form_input->whatever_text} gt = '>';
{whatever_text->html_code,html_code} lt_slash = '</';
{whatever_text->html_code,html_code} lt_bracket = '<[';
{html_code->whatever_text} gt_bracket = ']>';
{wig_block} comment=comment;
{wig_block} l_par = '(';
{wig_block} r_par = ')';
{wig_block} l_bracket = '[';
{wig_block} r_bracket = ']';
{wig_block} comma = ',';
{wig_block} keep = '\+';
{wig_block} remove = '\-';
{wig_block} join = '<<';
{wig_block} eq = '==';
{wig_block} neq = '!=';
{wig_block} lteq = '<=';
{wig_block} gteq = '>=';
{wig_block} not = '!';
{wig_block} minus = '-';
{wig_block} plus = '+';
{wig_block} mult = '*';
{wig_block} div = '/';
{wig_block} mod = '%';
{wig_block} and = '&&';
{wig_block} or = '||';
{wig_block} dot = '.';
{wig_block,html_code,form_input} eol = eol;
{wig_block,html_code,form_input} blank = (tab|' '|eol)*;
/*********************
* Literals *
*********************/
{wig_block,html_code,form_input} identifier = letter_or_us (letter_or_us|digit)*; // usual identifiers
{wig_block, form_input, html_code} stringconst = string_const ; // usual string constants
{html_code} meta = meta_stmt; // any string of the form <!-- ... -->
{whatever_text} whatever = whatever_stmt; // any string not containing < or >
/*********************
* Ignored Tokens *
*********************/
Ignored Tokens
blank, comment, eol;

Productions

    service = T.service l_brace P.html+ P.schema* variable* function* P.session+ r_brace
        {-> New service([html], [schema], [variable], [function], [session])};

    html = const T.html identifier assign html_tag_start htmlbody* html_tag_end semicolon
        {-> New html(identifier, [htmlbody])};

    htmlbody{->htmlbody} = 
      {tag_start} lt identifier attribute* gt
        {->New htmlbody.tag_start(identifier, [attribute])}
    | {tag_end} lt_slash identifier gt
        {->New htmlbody.tag_end(identifier)}
    | {hole} lt_bracket identifier gt_bracket
        {->New htmlbody.hole(identifier)}
    | {whatever} whatever 
        {->New htmlbody.whatever(whatever)}
    | {meta} meta 
        {->New htmlbody.meta(meta)}
    | {input} lt T.input inputattr+ gt
        {->New htmlbody.input(T.input, [inputattr])}
    | {select} lt [select_tag]:select inputattr+ [first_gt]:gt htmlbody* lt_slash select [second_gt]:gt
        {->New htmlbody.select(select_tag, [inputattr], first_gt, [htmlbody])};

    inputattr{->inputattr} = 
      {name} name assign attr 
        {->New inputattr.name(name, attr.attr)}
    | {type} T.type assign inputtype 
        {->New inputattr.type(T.type, inputtype)}
    | {attribute} attribute 
        {->New inputattr.attribute(attribute)};

    inputtype{->inputtype} =
      {texttype} text 
        {->New inputtype.texttype(text)}
    | {radiotype} radio 
        {->New inputtype.radiotype(radio)}
    | {strtype} stringconst 
        {->New inputtype.strtype(stringconst)};

    attribute {->attribute} =
      {attr} attr 
        {->New attribute.attr(attr.attr)}
    | {assign} [left_attr]:attr assign [right_attr]:attr
        {->New attribute.assign(left_attr.attr, right_attr.attr)};

    attr{->attr} =
      {id} identifier 
        {->New attr.id(identifier)}
    | {str} stringconst 
        {->New attr.str(stringconst)}
    | {iconst} P.intconst 
        {->New attr.iconst(intconst)};

    intconst{->P.intconst} =
      {negint}  negint_const
        {->New intconst.negint(negint_const)}
    | {posint} posint_const 
        {->New intconst.posint(posint_const)};

    schema = T.schema identifier l_brace field* r_brace
        {->New schema( identifier, [field])};

    field{->field} = simpletype identifier semicolon 
        {-> New field(simpletype.type, identifier)};

    variable{->variable} = P.type identifiers semicolon
        {->New variable(P.type, [identifiers.identifier])};

    identifiers{->identifier*} =
      {one} identifier
        {->[identifier]}
    | {many} identifiers comma identifier
        {-> [identifiers.identifier, identifier]};

    simpletype{->P.type} =
      {int} int 
        {->New type.int(int)}
    | {bool} bool 
        {->New type.bool(bool)}
    | {string} string 
        {->New type.string(string)}
    | {void} void 
        {->New type.void(void)};

    type{->P.type} =
      {simple} simpletype
        {->simpletype.type}
    | {tuple} tuple identifier
        {->New type.tuple(identifier)};

    function{->function} = P.type identifier l_par arguments? r_par compoundstm
        {->New function(P.type, identifier, [arguments.argument], compoundstm)};

    arguments{->argument*} =
      {one} argument 
        {->[argument]}
    | {many} arguments comma argument 
        {-> [arguments.argument, argument]};

    argument{->argument} = P.type identifier 
        {->New argument(P.type, identifier)};

    session = T.session identifier l_par r_par compoundstm
        {->New session(identifier, compoundstm)};

    stm{->stm?} =
      {empty} semicolon 
        {->New stm.empty()}
    | {show} show document P.receive? semicolon
        {-> New stm.show(document, P.receive)}
    | {exit} exit document semicolon 
        {-> New stm.exit(document)}
    | {return} return semicolon 
        {-> New stm.return()}
    | {returnexp} return exp semicolon 
        {-> New stm.returnexp(exp)}
    | {if} if l_par exp r_par stm 
        {-> New stm.if(exp, stm)}
    | {ifelse} if l_par exp r_par [then_stm]:stm_no_short_if else [else_stm]:stm
        {-> New stm.ifelse(exp, then_stm.stm, else_stm)}
    | {while} while l_par exp r_par stm 
        {-> New stm.while(exp, stm)}
    | {comp} compoundstm 
        {-> New stm.comp(compoundstm)}
    | {exp} exp semicolon 
        {-> New stm.exp(exp)};

    stm_no_short_if{->stm} =
      {empty} semicolon 
        {->New stm.empty() }
    | {show} show document P.receive? semicolon
        {->New stm.show(document, P.receive) }
    | {exit} exit document semicolon 
        {-> New stm.exit(document)}
    | {return} return semicolon 
        {-> New stm.return()}
    | {returnexp} return exp semicolon 
        {-> New stm.returnexp(exp)}
    | {ifelse} if l_par exp r_par [then_stm]:stm_no_short_if else [else_stm]:stm_no_short_if
        {-> New stm.ifelse(exp, then_stm.stm, else_stm.stm)}
    | {while} while l_par exp r_par stm_no_short_if
        {-> New stm.while(exp, stm_no_short_if.stm)}
    | {comp} compoundstm 
        {-> New stm.comp(compoundstm)}
    | {exp} exp semicolon 
        {-> New stm.exp(exp)};

    document =
      {id} identifier 
        {-> New document.id(identifier)}
    | {plug} T.plug identifier l_bracket plugs r_bracket
        {-> New document.plug(identifier, [plugs.plug])};

    receive = T.receive l_bracket inputs r_bracket
        {-> New receive([inputs.input])};

    compoundstm = l_brace variable* stm* r_brace
        {-> New compoundstm([variable], [stm])};

    plugs{->P.plug*} =
      {one} P.plug 
        {->[P.plug]}
    | {many} P.plugs comma P.plug 
        {-> [plugs.plug, P.plug]};

    plug = identifier assign exp 
        {-> New plug(identifier, exp.exp)};

    inputs{->P.input*} =
      {one} P.input 
        {-> [P.input]}
    | {many} P.inputs comma P.input 
        {-> [inputs.input, input]};

    input = lvalue assign identifier 
        {-> New input(lvalue, identifier)};

    exp{->exp} =
      {assign} lvalue assign [right]:or_exp
        {-> New exp.assign(lvalue, right.exp)}
    | {default} [left]:or_exp 
        {-> left.exp};

    or_exp{->exp} =
      {or} [left]:or_exp or [right]:and_exp 
        {-> New exp.or(left.exp, right.exp)}
    | {default} [left]:and_exp 
        {-> left.exp};

    and_exp{->exp} =
      {and} [left]:and_exp and [right]:cmp_exp
        {-> New exp.and(left.exp, right.exp)}
    | {default} [left]:cmp_exp 
        {-> left.exp};

    cmp_exp{->exp} =
      {eq} [left]:add_exp eq [right]:add_exp
        {-> New exp.eq(left.exp, right.exp)}
    | {neq} [left]:add_exp neq [right]:add_exp
        {-> New exp.neq(left.exp, right.exp)}
    | {lt} [left]:add_exp lt [right]:add_exp
        {-> New exp.lt(left.exp, right.exp)}
    | {gt} [left]:add_exp gt [right]:add_exp
        {-> New exp.gt(left.exp, right.exp)}
    | {lteq} [left]:add_exp lteq [right]:add_exp
        {-> New exp.lteq(left.exp, right.exp)}
    | {gteq} [left]:add_exp gteq [right]:add_exp
        {-> New exp.gteq(left.exp, right.exp)}
    | {default} [left]:add_exp {-> left.exp};

    add_exp{->exp} =
      {plus} [left]:add_exp plus [right]:mult_exp
        {-> New exp.plus(left.exp, right.exp)}
    | {minus} [left]:add_exp minus [right]:mult_exp
        {-> New exp.minus(left.exp, right.exp)}
    | {default} [left]:mult_exp 
        {-> left.exp};

    mult_exp{->exp} =
      {mult} [left]:mult_exp mult [right]:join_exp
        {-> New exp.mult(left.exp, right.exp)}
    | {div} [left]:mult_exp div [right]:join_exp
        {-> New exp.div(left.exp, right.exp)}
    | {mod} [left]:mult_exp mod [right]:join_exp
        {-> New exp.mod(left.exp, right.exp)}
    | {default} [left]:join_exp 
        {-> left.exp};

    join_exp{->exp} =
      {join} [left]:tuple_exp join [right]:join_exp
        {-> New exp.join(left.exp, right.exp)}
    | {default} [left]:tuple_exp 
        {-> left.exp};

    tuple_exp{->exp} =
      {keep} [left]:tuple_exp keep identifier
        {-> New exp.keep(left.exp, identifier)}
    | {remove} [left]:tuple_exp remove identifier
        {-> New exp.remove(left.exp, identifier)}
    | {keep_many} [left]:tuple_exp keep l_par identifiers r_par
        {-> New exp.keep_many(left.exp, [identifiers.identifier])}
    | {remove_many} [left]:tuple_exp remove l_par identifiers r_par
        {-> New exp.remove_many(left.exp, [identifiers.identifier])}
    | {default} [left]:unary_exp
        {-> left.exp};

    unary_exp{->exp} =
      {not} not [left]:base_exp 
        {-> New exp.not(left.exp)}
    | {neg} minus [left]:base_exp 
        {-> New exp.neg(left.exp)}
    | {default} [left]:base_exp 
        {-> left.exp};

    base_exp{->exp} =
      {lvalue} lvalue 
        {-> New exp.lvalue(lvalue)}
    | {call} identifier l_par exps? r_par
        {-> New exp.call(identifier, [exps.exp])}
    | {int} P.intconst 
        {-> New exp.int(intconst)}
    | {true} true 
        {-> New exp.true(true)}
    | {false} false 
        {-> New exp.false(false)}
    | {string} stringconst 
        {-> New exp.string(stringconst)}
    | {tuple} tuple l_brace fieldvalues? r_brace
        {-> New exp.tuple([fieldvalues.fieldvalue])}
    | {paren} l_par exp r_par
        {-> exp.exp};

    exps{->exp*} =
      {one} exp 
        {-> [exp]}
    | {many} exps comma exp 
        {-> [exps.exp, exp]};

    lvalue =
      {simple} identifier 
        {-> New lvalue.simple(identifier)}
    | {qualified} [left]:identifier dot [right]:identifier
        {-> New lvalue.qualified(left, right)};

    fieldvalues{->fieldvalue*} =
      {one} fieldvalue 
        {-> [fieldvalue]}
    | {many} fieldvalues comma fieldvalue
        {-> [fieldvalues.fieldvalue, fieldvalue]};

    fieldvalue = identifier assign exp 
        {-> New fieldvalue(identifier, exp)};

Abstract Syntax Tree

    service = P.html+ P.schema* variable* function* P.session+;

    html = identifier htmlbody*;
    
    htmlbody = 
          {tag_start} identifier attribute*
        | {tag_end} identifier
        | {hole} identifier
        | {whatever} whatever
        | {meta} meta
        | {input} T.input inputattr+
        | {select} [select_tag]:select inputattr+ [first_gt]:gt htmlbody*;

    inputattr = 
          {name} name attr
        | {type} T.type inputtype
        | {attribute} attribute
        ;

    inputtype = 
          {texttype} text
        | {radiotype} radio
        | {strtype} stringconst;

    attribute = 
          {attr} attr
        | {assign} [left_attr]:attr [right_attr]:attr;

    attr = 
          {id} identifier
        | {str} stringconst
        | {iconst} P.intconst;

    intconst = 
         {negint} negint_const
        |{posint} posint_const;

    schema = identifier field*;
    field = P.type identifier;
    variable = P.type identifier+;
    identifiers = identifier*;

    type = 
          {int} int
        | {bool} bool
        | {string} string
        | {void} void
        | {simple} P.type
        | {tuple} identifier;

    function = P.type identifier argument* compoundstm;
    arguments = argument*;
    argument = P.type identifier;
    session = identifier compoundstm;

    stm = 
          {empty}
        | {show} document P.receive?
        | {exit} document
        | {return}
        | {returnexp} exp
        | {if} exp stm
        | {ifelse} exp [then_stm]:stm [else_stm]:stm
        | {while} exp stm
        | {comp} compoundstm
        | {exp} exp;

    document = 
          {id} identifier
        | {plug} identifier P.plug*;

    receive = P.input*;

    compoundstm = variable* stm*;

    plugs = P.plug*;
    plug = identifier exp;

    inputs = P.input*;
    input = lvalue identifier;

    exp = 
          {assign} lvalue [right]:exp
        | {or} [left]:exp [right]:exp
        | {and} [left]:exp [right]:exp
        | {eq} [left]:exp [right]:exp
        | {neq} [left]:exp [right]:exp
        | {lt} [left]:exp [right]:exp
        | {gt} [left]:exp [right]:exp
        | {lteq} [left]:exp [right]:exp
        | {gteq} [left]:exp [right]:exp
        | {plus} [left]:exp [right]:exp
        | {minus} [left]:exp [right]:exp
        | {mult} [left]:exp [right]:exp
        | {div} [left]:exp [right]:exp
        | {mod} [left]:exp [right]:exp
        | {join} [left]:exp [right]:exp
        | {keep} [left]:exp identifier
        | {remove} [left]:exp identifier
        | {keep_many} [left]:exp identifier+
        | {remove_many} [left]:exp identifier+
        | {not} [left]:exp
        | {neg} [left]:exp
        | {default} [left]:exp
        | {lvalue} lvalue
        | {call} identifier exp*
        | {int} P.intconst
        | {true} true
        | {false} false
        | {string} stringconst
        | {tuple} fieldvalue*
        | {paren} exp;

    exps = exp*;

    lvalue = 
          {simple} identifier 
        | {qualified} [left]:identifier [right]:identifier;
    
    fieldvalues = fieldvalue*;
    fieldvalue = identifier exp;

